<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Transcription Page</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-gradient-to-b from-slate-50 to-white text-slate-800">
    <div id="root"></div>

    <script>
      const { useState, useRef } = React;

      // Compute API base to the local proxy (required for Docker→frontend comms)
      const API_BASE = `${location.protocol}//${location.hostname}:8001`;
      const MODEL_ID = 'Systran/faster-distil-whisper-small.en';
      const ENDPOINT_PATH = '/v1/audio/transcriptions';

      // Helpers to build 16kHz mono WAV
      function mergeFloat32(arrays) {
        let length = 0;
        arrays.forEach(a => length += a.length);
        const result = new Float32Array(length);
        let offset = 0;
        arrays.forEach(a => { result.set(a, offset); offset += a.length; });
        return result;
      }
      function downsampleTo16k(float32, inRate) {
        const outRate = 16000;
        if (inRate === outRate) return float32;
        const ratio = inRate / outRate;
        const newLen = Math.floor(float32.length / ratio);
        const out = new Float32Array(newLen);
        for (let i = 0; i < newLen; i++) {
          const idx = i * ratio;
          const idx1 = Math.floor(idx);
          const idx2 = Math.min(idx1 + 1, float32.length - 1);
          const frac = idx - idx1;
          out[i] = float32[idx1] * (1 - frac) + float32[idx2] * frac;
        }
        return out;
      }
      function floatTo16BitPCM(float32) {
        const buf = new ArrayBuffer(float32.length * 2);
        const view = new DataView(buf);
        let offset = 0;
        for (let i = 0; i < float32.length; i++, offset += 2) {
          let s = Math.max(-1, Math.min(1, float32[i]));
          view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        return new Uint8Array(buf);
      }
      function encodeWavPCM16(mono16, sampleRate) {
        const numChannels = 1;
        const bytesPerSample = 2;
        const blockAlign = numChannels * bytesPerSample;
        const byteRate = sampleRate * blockAlign;
        const dataSize = mono16.length;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        function writeString(off, str) { for (let i=0; i<str.length; i++) view.setUint8(off+i, str.charCodeAt(i)); }
        let offset = 0;
        writeString(offset, 'RIFF'); offset += 4;
        view.setUint32(offset, 36 + dataSize, true); offset += 4;
        writeString(offset, 'WAVE'); offset += 4;
        writeString(offset, 'fmt '); offset += 4;
        view.setUint32(offset, 16, true); offset += 4; // PCM chunk size
        view.setUint16(offset, 1, true); offset += 2; // PCM format
        view.setUint16(offset, numChannels, true); offset += 2;
        view.setUint32(offset, sampleRate, true); offset += 4;
        view.setUint32(offset, byteRate, true); offset += 4;
        view.setUint16(offset, blockAlign, true); offset += 2;
        view.setUint16(offset, 16, true); offset += 2; // bits per sample
        writeString(offset, 'data'); offset += 4;
        view.setUint32(offset, dataSize, true); offset += 4;
        new Uint8Array(buffer, 44).set(mono16);
        return new Blob([buffer], { type: 'audio/wav' });
      }

      function App() {
        const [recording, setRecording] = useState(false);
        const [seconds, setSeconds] = useState(0);
        const timerRef = useRef(null);
        const [busy, setBusy] = useState(false);
        const [errorMsg, setErrorMsg] = useState('');
        const [transcript, setTranscript] = useState('');
        const [txtUrl, setTxtUrl] = useState('');

        // Audio internals
        const ctxRef = useRef(null);
        const streamRef = useRef(null);
        const sourceRef = useRef(null);
        const processorRef = useRef(null);
        const chunksRef = useRef([]);

        async function startRecording() {
          setErrorMsg('');
          setTranscript('');
          if (txtUrl) { URL.revokeObjectURL(txtUrl); setTxtUrl(''); }
          setSeconds(0);
          chunksRef.current = [];
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            streamRef.current = stream;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            const ctx = new AudioCtx();
            ctxRef.current = ctx;
            const source = ctx.createMediaStreamSource(stream);
            sourceRef.current = source;
            const processor = ctx.createScriptProcessor(4096, 1, 1);
            processorRef.current = processor;
            processor.onaudioprocess = (e) => {
              const input = e.inputBuffer.getChannelData(0);
              chunksRef.current.push(new Float32Array(input));
            };
            source.connect(processor);
            processor.connect(ctx.destination);
            setRecording(true);
            timerRef.current = setInterval(() => setSeconds((s) => s + 1), 1000);
          } catch (e) {
            stopRecordingInternals();
            setErrorMsg(e?.message || String(e));
          }
        }

        function stopRecordingInternals() {
          if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
          try { processorRef.current && processorRef.current.disconnect(); } catch(_){}
          try { sourceRef.current && sourceRef.current.disconnect(); } catch(_){}
          try { ctxRef.current && ctxRef.current.close(); } catch(_){}
          try { streamRef.current && streamRef.current.getTracks().forEach(t => t.stop()); } catch(_){}
          processorRef.current = null; sourceRef.current = null; ctxRef.current = null; streamRef.current = null;
          setRecording(false);
        }

        async function stopAndTranscribe() {
          if (!recording) return;
          stopRecordingInternals();
          setBusy(true);
          setErrorMsg('');
          try {
            const ctx = ctxRef.current; // may be null if closed, so capture rate first
            const sampleRate = (ctx && ctx.sampleRate) || 44100;
            const merged = mergeFloat32(chunksRef.current);
            const resampled = downsampleTo16k(merged, sampleRate);
            const pcm16 = floatTo16BitPCM(resampled);
            const blob = encodeWavPCM16(pcm16, 16000);

            const form = new FormData();
            form.append('file', blob, 'speech.wav');
            form.append('model', MODEL_ID);
            const url = `${API_BASE}${ENDPOINT_PATH}`;
            const resp = await fetch(url, { method: 'POST', body: form });
            if (!resp.ok) {
              const text = await resp.text().catch(() => '');
              throw new Error(text || resp.statusText || `HTTP ${resp.status}`);
            }
            const ctype = resp.headers.get('content-type') || '';
            if (ctype.includes('application/json')) {
              const json = await resp.json();
              setTranscript(json.text || json.transcript || (json.data && json.data.text) || JSON.stringify(json));
            } else {
              setTranscript(await resp.text());
            }

            const txtBlob = new Blob([transcript || ''], { type: 'text/plain' });
            const urlTxt = URL.createObjectURL(txtBlob);
            if (txtUrl) URL.revokeObjectURL(txtUrl);
            setTxtUrl(urlTxt);
          } catch (e) {
            setErrorMsg(e?.message || String(e));
          } finally {
            setBusy(false);
          }
        }

        function resetAll() {
          stopRecordingInternals();
          setErrorMsg('');
          setTranscript('');
          if (txtUrl) { URL.revokeObjectURL(txtUrl); setTxtUrl(''); }
          setSeconds(0);
        }

        return (
          React.createElement('div', { className: 'max-w-2xl mx-auto px-4 py-8' },
            React.createElement('div', { className: 'mb-6' },
              React.createElement('h1', { className: 'text-2xl font-semibold tracking-tight' }, 'Transcription Page'),
              React.createElement('p', { className: 'text-slate-500' }, 'Start recording, then stop to transcribe via the local proxy.')
            ),
            React.createElement('div', { className: 'bg-white shadow-sm ring-1 ring-slate-200 rounded-xl p-4 md:p-6 space-y-4' },
              React.createElement('div', { className: 'flex items-center gap-3' },
                !recording ? (
                  React.createElement('button', { className: 'inline-flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg shadow-sm disabled:opacity-50', onClick: startRecording, disabled: busy },
                    React.createElement('span', { className: 'w-2 h-2 rounded-full bg-green-300 animate-pulse' }),
                    'Start Recording')
                ) : (
                  React.createElement('button', { className: 'inline-flex items-center gap-2 bg-rose-600 hover:bg-rose-700 text-white px-4 py-2 rounded-lg shadow-sm', onClick: stopAndTranscribe },
                    React.createElement('span', { className: 'w-2 h-2 rounded-full bg-rose-300 animate-ping' }),
                    'Stop & Transcribe')
                ),
                React.createElement('div', { className: 'text-slate-500 text-sm' }, recording ? `Recording… ${seconds}s` : (seconds ? `Recorded ${seconds}s` : 'Idle')),
                busy && React.createElement('div', { className: 'text-slate-500 text-sm' }, 'Transcribing…'),
                React.createElement('button', { className: 'ml-auto text-sm text-slate-500 hover:text-slate-700', onClick: resetAll, title: 'Reset' }, 'Reset')
              ),
              errorMsg && React.createElement('div', { className: 'text-rose-700 bg-rose-50 border border-rose-200 rounded-lg p-3 text-sm whitespace-pre-wrap' }, errorMsg),
              transcript && React.createElement('div', { className: 'space-y-2' },
                React.createElement('div', { className: 'text-sm font-medium text-slate-700' }, 'Transcript'),
                React.createElement('pre', { className: 'bg-slate-50 border border-slate-200 rounded-lg p-3 whitespace-pre-wrap font-mono text-sm' }, transcript),
                txtUrl && React.createElement('div', { className: 'flex gap-3' },
                  React.createElement('a', { className: 'inline-flex items-center gap-2 text-blue-700 hover:text-blue-800 text-sm', href: txtUrl, download: 'transcript.txt' }, 'Download transcript.txt'),
                  React.createElement('button', { className: 'text-sm text-slate-600 hover:text-slate-800', onClick: () => navigator.clipboard && navigator.clipboard.writeText(transcript) }, 'Copy')
                )
              )
            ),
            React.createElement('p', { className: 'text-xs text-slate-400 mt-4' }, `Proxy: ${API_BASE} (required). Endpoint: ${ENDPOINT_PATH}. Model: ${MODEL_ID}.`)
          )
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
  </html>
